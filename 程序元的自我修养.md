Title: Programmer's self promote
## SMP & multi-core
symmetrical mulit-processor 
There are truelly multi-cpus in 

#MC
多个核心共享缓存，并且包装成一个外观进行销售

## 1.6
进程的资源包括：内存空间（数据段，程序段，堆段），文件，信号等

线程的访问权限：
栈
线程局部存储(TLS)
寄存器（包括PC寄存器），**寄存器是执行流的基本数据**，因此为线程私有

表1.1很牛逼



线程的优先级提升有三种方式；
用户指定
根据进入等待状态的频繁程度提升或者降低优先级
长时间得不到CPU而被提升


**抢占式线程：**
调度时间是固定的，无非两种情况：
1.当线程等待IO
2.线程主动放弃CPU

可以避免一些因为抢占式线程里调度时机不确定产生的问题，即便如此非抢占式线程今日已经十分少见


我们把单指令的操作成为是原子的，因为无论如何，单指令的执行是不会被打断的。

例如inc就可以直接增加一个内存单元

**原子操作的弊端**
试用于比较简单的场合，如果我们要保证一个复杂的数据结构更改的原子性，使用原子操作就力不从心了。


**同步**
各个线程同步访问，
所谓同步就是指一个线程再访问数据未结束的时候，其他线程不得对同一个数据进行访问，如此对于数据的访问就被原子化了。

### 锁是一种机制
**同步的最简单方式就是使用锁，锁是一种非强制机制，每个线程再访问数据或者资源之前，先试图获取（Acquire锁）, 并再访问之后释放锁(release)**,在锁已经被占用的时候，线程试图获取锁，就会等待。

#### 二元信号量（binary Semaphore），是一种最简单的锁
它只有两种状态：占用和非占用，它时候于只能被一个线程单独访问的资源，


#### 允许多个线程并发访问的资源，多元信号量，简称（信号量）
一个初值为N的信号量，允许N个线程并发访问。线程访问资源的时候熟悉获取信号量

获取操作：
将信号量－1
如果信号量小于0，则进入等待状态，否则继续执行

访问完资源，线程释放信号量，进行如下操作：
将信号量＋1
如果信号量小于1，则唤醒一个等待中的线程。


#### 互斥量和二元信号量
Mutex和二元信号量很蕾丝，资源只允许同一个线程访问，但和信号量不同的是：**信号量在整个系统可以被任意线程获取并释放，也就是说，同一个信号量可以被系统中的一个线程获取之后由另外一个线程释放**
互斥量要求是那个线程获取，就要求由那个线程释放

#### 临界区

是一种比互斥量更严格的同步手段。
把临界区的锁的获取，成为进入临界区，把锁的释放称为离开临界区。

临界区和互斥量和信号量的区别在于：
Mutex,信号量在系统的任何进程都是可见的。也就是，一个进程创建了一个Mutex和信号量，另外一个进程试图获取该锁是合法的。而临界区的作用在于本进程，其他进程无法获取该锁。**除此之外，临界区具有和互斥量相同的性质**


#### 读写锁
适用于特殊的条件
这个锁有三种状态
当要进行读取的时候，以shared的方式获取锁；当要进行写入的时候，以exclusive的方式获取锁
free
shared
exclusive


#### 条件变量
使用条件变量可以让多个线程一起等待事件的发生，当事件发生时，所有线程可以一起恢复。


### 可重入与线程安全
一个函数被重入，表示这个函数没有执行完成，由于外部因素或者内部调用，又一次被执行

函数要被重入，只有两种可能：
1. 多个线程同时执行这个函数
2. 函数调用自身。

#### 函数是可重入的，也就是说，该函数被重入不产生不良后果
一个可重入的函数可以在多线程环境下安全执行，
一个函数要成为可重入的需要：


1. 不使用任何静态的或者全局的非const变量
2. 不返回任何静态的或者全局的非conse变量
3. 只依赖于调度方的参数
4. 不调用任何不可重入的函数
5. 不依赖任何单个资源的锁(mutex) 这个是什么意思？？？？？？？
### 过度优化有可能使得线程不安全

可以使用volatile关键自防止过度优化，
volatile可以做到两件事情
（1） 防止编译器为了提高速度将变量缓存到寄存器不写回
 （2）防止编译器调整指令序列
 
 
 
### Singleton 单例模式于线程安全的问题

volatile T * pInst = 0;
T* GetInstance()
{
	if(pInst == NULL)
	{
		lock ();
		if (pInst == NULL)
			pInst = new T;
		unlock();
	}
	
	return pInst;
}


C＋＋的new是分为两不执行的：
1. 分配内存
2. 调用构造函数
3。 将内存地址赋给pInst

2, 3可以调换顺序，如果真的发生了调换顺序，而又在别的地方引用了这个对象。


现在很多体系结构都提供了barrier指令，用来保证线程安全，

lock();
if (!pInst)
{
	T* temp = new T;
	barrier();
	pInst = temp;
}
unlock();


## 多线程的内部情况

**linux使用clone产生的线程就是一个一对一的线程**
难道使用fork和exec产生的就不是一个线程？

一对一
多对一
多对多


