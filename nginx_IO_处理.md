异步非阻塞的方式来处理IO
首先说阻塞
建立连接，接受数据，发送数据到系统底层都是数据的读写操作，采用阻塞的调用，如果数据没有准备好，阻塞到系统调用上，CPU就会让出来，利用率变低。worker是单线程模式的，连接数量很多，一个连接的数据没准备好，所有的其他连接即使数据已经准备好了，也不能使用这样不合理，CPU没人利用不行。

再说明异步
不阻塞了，但是想要知道数据是否准备好了，就得不断的轮询，轮询也回带来开销。所以采用异步方式，当数据准备好的时候内核发送信息通知。poll这样的系统调用就解决了问题
int pull(struct pollfd *fdarray, unsigned long fds, int timeout);
若有就绪描述符则返回就绪描述符个数

struct{
	int fd;
	short events; //关心的事件类型，
	short revents; //return events 返回的事件类型
}

所以程序只是在不断处理已经就绪的数据。

worker的个数应该和cpu绑定也是因为这个原因


阻塞：阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干（或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。

非阻塞忙轮询：接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂个电话：“你到了没？”

于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。

